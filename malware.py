from abc import ABC, abstractmethod
from checkings import *


class Malware(ABC):
    """
    An abstract class that represents malware
    """
    __possible_values = "ABCDEF0123456789"
    __max_str_length = 250
    __signature_length = 48

    def __init__(self, program_name: str, unique_signature: str):
        """
        Constructor that sets current malware fields
        :param program_name: name of program of a string type
        :param unique_signature: program unique signature of string type
        :raises ValueError - if one of passed arguments has not valid format
        :raises TypeError - if one of passed arguments has not valid type
        """
        self.program_name = program_name
        self.unique_signature = unique_signature

    @property
    def program_name(self) -> str:
        """
        Getter returns the malware's name
        :return: Malware's name of a string type
        """
        return self.__program_name

    @program_name.setter
    def program_name(self, program_name: str) -> None:
        """
        Setter sets the malware program_name
        :param program_name: A value to set the malware name to
        :raises ValueError - if the given value contains more characters than allowed
        :raises TypeError - if program_name doesn't have a valid type
        :return: None
        """
        if not Checkings.check_type(program_name, str):
            raise TypeError("Program name should be of a string type")
        if not Checkings.check_str_length(program_name, self.__max_str_length):
            raise ValueError("The program name value has invalid format")
        self.__program_name = program_name

    @property
    def unique_signature(self) -> str:
        """
         Getter returns the malware's unique signature
        :return: Malware's unique signature of a string type
        """
        return self.__unique_signature

    @unique_signature.setter
    def unique_signature(self, unique_signature: str) -> None:
        """
        Setter sets the malware unique signature
        :param unique_signature: string to check
        :raises ValueError - if the given value of unique_signature contains more than __signature_length characters, has invalid type
        or contains letters and aren't allowed and not represented in __possible_values
        :raises TypeError - if unique_signature has not valid type
        :return: None
        """
        if not Checkings.check_type(unique_signature, str):
            raise TypeError("Program signature should be of a string type")
        if not Checkings.check_length_and_chars(unique_signature, self.__signature_length, self.__possible_values):
            raise ValueError("The signature length or/and value is invalid")

        self.__unique_signature = unique_signature

    def __str__(self) -> str:
        """
        String represents all malware attributes in a format that is convenient for the user
        :return: string that contains malware's attributes
        """
        return f"A program name is {self.program_name}, it's unique signature is {self.unique_signature}"


